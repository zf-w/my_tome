---
description: "二〇二四年十月的第二周"
long_title: "二零二四年十月第二周日记 - 之枫"
---

# 十月七日周一

今天早上, 我很顺利很顺利的就回顾了我之前的"learn_blender"部分的代码, 并加入了我为了"cs415"设计的制作浮空迷宫的想法. 啊啊啊啊真的是太顺利了. 真真是鲜花着锦, 烈火烹油, 月满则亏, 水满则溢, 是登高必跌重. 婶子我怎么连这个道理都不知道.

把迷宫做出来感觉还是很酷的. 我想确实学 CS 的第一件事情就是要思考命名规范. 相对系统了之后感觉真的很美妙, 就像是逐渐形成了一种"hash"的结构, 很快就能确定如果我要这么设计这部分代码, 那变量名应该叫什么, 同时也保证之后写的过程中能明确地知道自己之前的设计是什么而不用每次都回去找. 确实很奇妙的感觉.

## 每日一题

今天的每日一题本来我还没思路. 但是想到之前的题目, 静下心来, 做了一会儿别的事情之后就想到了. 我想到, 如果要是从一个字符一个字符读入的角度去思考呢. 然后我就发觉了其中的小小奥秘.

```rust
pub fn min_swaps(s: String) -> i32 {
    let mut vec_stk: Vec<bool> = Vec::new();
    for c in s.chars() {
        if c == '[' {
            vec_stk.push(true);
        } else {
            if let Some(last_flag) = vec_stk.last().cloned() {
                if last_flag == true {
                    vec_stk.pop();
                } else {
                    vec_stk.push(false);
                }
            }
        }
    }
    (vec_stk.len() / 2 + vec_stk.len() % 2) as i32
}
```

# 十月八日周二

今天是有课的一天. 早上倒是没有什么异常发生.

下午上课前我总感觉空空的, 进入电梯发现原来是手表忘记带了.

# 十月九日周三

今天的每日一题还是"stack"相关, 所以还蛮迅速嘟.

明天的每日一题不是"stack"了. 起码我没想出"stack"的版本. 不过总归明天是可以小小轻松一下.

## 明天的每日一题

虽然是独立解出来的, 但是比较慢哈哈哈.

```rust
use std::collections::BTreeMap;
pub fn max_width_ramp(nums: Vec<i32>) -> i32 {
    let mut mp: BTreeMap<i32, usize> = BTreeMap::new();
    let mut ans_max_len: usize = 0;
    for (i, num) in nums.into_iter().enumerate() {
        let prev_i = if let Some((_, last_idx_ref)) = mp.range(..=num).last() {
            last_idx_ref.clone()
        } else {
            i
        };

        ans_max_len = ans_max_len.max(i - prev_i);
        use std::collections::btree_map::Entry;
        match mp.entry(num) {
            Entry::Vacant(vacant_entry) => {
                vacant_entry.insert(prev_i);
            }
            _ => (),
        }
    }
    ans_max_len as i32
}
```

## CS233 Lab

```verilog
`define OP0_LOOP    6'h2c

module mips_decode(ALUOp, RegWrite, BEQ, ALUSrc, MemRead, MemWrite, MemToReg, RegDst, new_inst,
                   opcode, funct);

   output [2:0] ALUOp;
   output       RegWrite, BEQ, ALUSrc, MemRead, MemWrite, MemToReg, RegDst, new_inst;
   input  [5:0] opcode, funct;

   wire new_inst = (opcode == 6'b0) & (funct == `OP0_LOOP); // boolean expression for when it's the new instruction

   // control signals for new instruction
   wire [2:0] new_ALUOp = `ALU_SUB;
   wire new_RegWrite    = 1;
   wire new_BEQ         = 0;
   wire new_ALUSrc      = 0;
   wire new_MemRead     = 0;
   wire new_MemWrite    = 0;
   wire new_MemToReg    = 0;
   wire new_RegDst      = 0;

   wire [2:0] given_ALUOp;
   wire       given_RegWrite, given_BEQ, given_ALUSrc, given_MemRead,
              given_MemWrite, given_MemToReg, given_RegDst;
   given_decode given(given_ALUOp, given_RegWrite, given_BEQ, given_ALUSrc,
                      given_MemRead, given_MemWrite, given_MemToReg, given_RegDst,
                      opcode, funct);
   mux2v #(3) ALUOp_mux(ALUOp, given_ALUOp, new_ALUOp, new_inst);
   mux2v #(1) RegWrite_mux(RegWrite, given_RegWrite, new_RegWrite, new_inst);
   mux2v #(1) BEQ_mux(BEQ, given_BEQ, new_BEQ, new_inst);
   mux2v #(1) ALUSrc_mux(ALUSrc, given_ALUSrc, new_ALUSrc, new_inst);
   mux2v #(1) MemRead_mux(MemRead, given_MemRead, new_MemRead, new_inst);
   mux2v #(1) MemWrite_mux(MemWrite, given_MemWrite, new_MemWrite, new_inst);
   mux2v #(1) MemToReg_mux(MemToReg, given_MemToReg, new_MemToReg, new_inst);
   mux2v #(1) RegDst_mux(RegDst, given_RegDst, new_RegDst, new_inst);

endmodule // mips_decode

module machine(clk, reset);
   input        clk, reset;

   wire [31:0]  PC;
   wire [31:2]  next_PC, PC_plus4, PC_target;
   wire [31:0]  inst;

   wire [31:0]  imm = {{ 16{inst[15]} }, inst[15:0] };  // sign-extended immediate
   wire [4:0]   rs = inst[25:21];
   wire [4:0]   rt = inst[20:16];
   wire [4:0]   rd = inst[15:11];
   wire [5:0]   opcode = inst[31:26];
   wire [5:0]   funct = inst[5:0];

   wire [4:0]   wr_regnum;
   wire [2:0]   ALUOp;

   wire         RegWrite, BEQ, ALUSrc, MemRead, MemWrite, MemToReg, RegDst;
   wire         PCSrc, zero, negative;
   wire [31:0]  rd1_data, rd2_data, B_data, alu_out_data, load_data, wr_data;


   wire alu_out_non_negative = ~negative;
   wire decoder_out_new_inst;
   wire [29:0] pc_new_inst_mux_out;
   wire [4:0] write_to_rs_mux_out;
   wire [31:0] new_inst_alu_mux_out;

   register #(30, 30'h100000) PC_reg(PC[31:2], next_PC[31:2], clk, /* enable */1'b1, reset);
   assign PC[1:0] = 2'b0;  // bottom bits hard coded to 00
   adder30 next_PC_adder(PC_plus4, PC[31:2], 30'h1);
   adder30 target_PC_adder(PC_target, PC_plus4, imm[29:0]);
   mux2v #(30) branch_mux(next_PC, pc_new_inst_mux_out, PC_target, PCSrc);
   assign PCSrc = BEQ & zero;

   instruction_memory imem (inst, PC[31:2]);

   mips_decode decode(ALUOp, RegWrite, BEQ, ALUSrc, MemRead, MemWrite, MemToReg, RegDst, decoder_out_new_inst,
                      opcode, funct);

   regfile rf (rd1_data, rd2_data,
               rs, rt, write_to_rs_mux_out, wr_data,
               RegWrite, clk, reset);

   mux2v #(32) imm_mux(B_data, rd2_data, imm, ALUSrc);
   alu32 alu(alu_out_data, zero, negative, ALUOp, rd1_data, new_inst_alu_mux_out);
   // First bug: I forgot to change this from `B_data` to `new_inst_alu_mux_out`.


   data_mem data_memory(load_data, alu_out_data, rd2_data, MemRead, MemWrite, clk, reset);

   mux2v #(32) wb_mux(wr_data, alu_out_data, load_data, MemToReg);
   mux2v #(5) rd_mux(wr_regnum, rt, rd, RegDst);

   // loop    rs, rt
   //    Decrement and jump register if counter is greater than or equal to zero.
   //    Useful for implementing counted loops.
   //    R-type
   //    opcode: 6'h00	funct: 6'h2c

   //    `define OP0_LOOP    6'h2c  # You will want to copy this line into machine.v.

   //    if R[rs] - 1 >= 0:
   //       PC = R[rt]
   //    R[rs] = R[rs] - 1

   mux2v #(5) write_to_rs_mux(write_to_rs_mux_out, wr_regnum, rs, decoder_out_new_inst);

   wire new_inst_and_non_negative = alu_out_non_negative & decoder_out_new_inst;
   mux2v #(30) pc_new_inst_mux(pc_new_inst_mux_out, PC_plus4, rd2_data[31:2], new_inst_and_non_negative);
   // Second bug: I incorrectly switched `rd2_data[31:2]` into `rd2_data[29:0]`.
   mux2v #(32) new_inst_alu_mux(new_inst_alu_mux_out, B_data, 32'b1, decoder_out_new_inst);
endmodule // machine
```

# 十月十日

今天有一些时间集中起来完成我的网站想法.

我想我是时候尝试一下子使用 Amazon 的 s3 之类了.

大概要分成两部分, 一部分是服务器端的验证, 一部分是客户端的 UI 调整, 比如说加上一个验证窗口, 还有相应的主题颜色调整, 语言选择等等.

我感觉我很累. 虽然每一步, 特别是计算机领域的每一步, 经过思考之后似乎都可以顺利的实现, 但是总感觉很疲惫. 我感觉我想的太多了, 越来越多. 我还感觉到与世界的一种割裂和距离. 并不是说世界就是混乱的, 但是确实有太多不能控制的东西. 曾经有一个好朋友和我说我似乎有点"拒人于千里之外". 另我十分不解, 但或许又淡淡地明白着. 这是另一种割裂感. 似乎如果只论行为地话, 但凡是个人, 特别是女生, 只要是想和我交流, 我必然会立刻回复. 或许可以和一个人很熟悉, 但是仍然感觉遥不可及. 似乎一个人和人的对话永远不可能达到和计算机或者这个世界的其它部分类似的深度. 我说不清是复杂还是简单. 我曾经觉得或许在于反馈. 但我现在不知道了. 为什么人会让人感觉不确定呢.

# 十月十一日周五

今天早上起来把昨天计划的按照语言"渲染"导航栏的设计实现了, 确实也是蛮顺利的. 然后我出门去采购东西, 买了点小软糖, 咖啡, 素鸡块, 一份速食早饭, 还有一份蓝莓. 好像到了大蓝莓的季节了.

吃了"早饭"和五个素鸡块. 计划收拾一下客厅桌面. 再倒杯咖啡.

# 十月十二日周六

这两天真的是非常的紧张. 实现了我很多的自己的小想法. 包括在网络 Cookie 中加入一些额外的信息去确保 Cookie 不会被挪用. 还有把密码的 Hash 在和时间结合 Hash 一遍, 相当于是 Time Based Token 的感觉.

# 十月十三日周日

```mips
.data
.align 2
# Test case 0
test0_item:   .word 2
test0_array:  .word 0 3 4 13
test0_start:  .word 0
test0_end:    .word 3
# Test case 1
test1_item:   .word 2
test1_array:  .word 1 2 3 4
test1_start:  .word 0
test1_end:    .word 3

.text
.globl  mips_asm
mips_asm:
ble $a2, $a3, else_if
    li $v0, -1
    jr $ra
else_if:
    move $t0, $a2
    mul $t0, $t0, 4
    add $t0, $t0, $a1
    lw $t0, 0($t0)
    bne $t0, $a0, else_if_1
    move $v0, $a2
    jr $ra
else_if_1:
    move $t0, $a3
    mul $t0, $t0, 4
    add $t0, $t0, $a1
    lw $t0, 0($t0)
    bne $t0, $a0, recurse
    move $v0, $a3
    jr $ra
recurse:

    addi $sp, $sp, -4
    sw $s0, 0($sp)
    move $s0, $ra

    addi $a2, $a2, 1
    addi $a3, $a3, -1 # 我意外地把这个`$a3`写成了`$s3`, 收获第一次"evil" case不得分哈哈哈.
    jal mips_asm

    move $ra, $s0
    lw $s0, 0($sp)
    addi $sp, $sp, 4
    jr $ra
```

## CS233 Exam 4

考试的结果还不错, 没错题. 一切都和练习的流程差不多. 不过也发生了一些有意思的事情: 很多我练习时候想到要注意的事情考试都忘记了哈哈哈, 不过好在都及时地意识到了.

## 散步

考试前我想确实要是考的不错的话应该去中心广场上走一走. 散散心, 毕竟最近的眼睛确实过于疲劳了. 溜达了一大圈, 感觉还不错. 然后我去"Target"买菜结账的时候, 一个女生过来拿一个塑料袋, 差点把塑料袋的架子弄翻, 我想扶一下, 但是碰到了她的手, 希望没有冒犯到. 当时她说了"Sorry", 我也立即回复了"No worries."
